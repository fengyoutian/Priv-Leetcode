# [数组排序](https://leetcode-cn.com/problems/sort-an-array/)

## 题目描述
    给定一个整数数组 nums，将该数组升序排列。

    示例 1：
    输入：[5,2,3,1]
    输出：[1,2,3,5]

    示例 2：
    输入：[5,1,1,2,0,0]
    输出：[0,0,1,1,2,5]

    提示：
        1 <= A.length <= 10000
        -50000 <= A[i] <= 50000

## 思路
- 冒泡排序 (Bubble Sort)
    ```
    无脑想到冒泡排序，提交超时。。。
    两个循环，两个数进行比较，满足条件（升序）的交换位置，直到循环结束
    1. 从相邻元素开始依次向右比较
    2. 比较元素大小，满足条件则交换位置
    3. 重复1、2步骤，直到循环结束
    ```
    + 瓶时间复杂度O(n^2)，最佳O(n)，最差O(n^2)
    + 空间复杂度O(1)
    + `稳定`的排序算法（`相等的元素排序前后不变`）

- 插入排序 (Insert Sort)
    ```
    每次将待插入的元素按照大小插入到前面已排序的适当位置上
    1. 从第一个元素开始，该元素默认已排序
    2. 取出下一个元素，在已排序的元素列表中从后向前遍历
    3. 如果该元素（已排序）大于待插入元素，则把它移动到下一个位置
    4. 重复步骤3，直到找到一个小于或等于待插入元素的位置，将待插入元素插入到下一个位置
    5. 重复步骤2~5，直到循环结束
    ```
    + 平均时间复杂度O(n^2)，最佳O(n)，最差O(n^2)
    + 空间复杂度O(1)
    + `稳定`的排序算法

- 选择排序 (Selection Sort)
    ```
    从未排序的数组中找到最小的元素，放到已排序数组的末尾，直到元素遍历结束
    1. 从未排序的所有元素中倒找最小元素
    2. 交换最小元素到已排序元素的下一位
    3. 重复1、2，直到循环结束
    ```
    + 时间复杂度O(n^2)，最佳最差一样
    + 空间复杂度O(1)
    + `不稳定`的排序算法（`相等的元素排序前后可能改变`）

- 希尔排序 (Shell Sort)
    + 也称为`增量递减排序`，基于以下性质对插入排序算法的改进
        - 插入排序在对几乎`已排好序`的数据操作时，效率高，可达到线性排序的效率
        - 但插入排序一般来说是低效的，因为插入排序每次只能`移动一位数据`
    ```
    希尔排序的改进：使用一个增量将数组拆分，然后在拆分后的组内进行插入排序，增量递减，直到增量为1，
    好处就是数据能跨多个元素移动，一次比较就可以消除多个元素交换：
    1. 选取一个递增排序，一般使用 x/2 或 x/3+1
    2. 使用序列中最大的增量，对数组分组，在组内进行插入排序，递减增量，直到为1
    ```
    + 时间复杂度与增量有关，可能为 O(n^2) > O(n^1.5) > O(nlg2n)
    + 空间复杂度O(1)
    + `不稳定`的排序算法

- 快速排序 (Quick Sort)
    + 快排好像是排序中运用最广泛的算法，`特点`是使用很小的铺助栈原地排序。它也是一个`分而治之`的排序算法。
    ```
    基本思想是：选取一个关键值，将数组分为两部分，一部分小于关键值，另一部分大于关键值，然后递归的对左右两部分排序。
    1. 选取 nums[low] 作为关键值（key）
    2. 使用两个指针（l：左指针，r：右指针）一左一右遍历数组，前后元素与key比较
    3. r指针向左移动找出小于 key 的元素，并覆盖到l指针（当前l指针的值已作为key保存）
    4. l指针向右移动找出大于 key 的元素，并覆盖到r指针
    5. 最后将key交换给l指针
    6. 递归左右部分进行排序
    ```
    + 平均时间复杂度O(nlgn)，最佳O(nlgn)，最差O(n^2)
    + 空间复杂度O(lgn)，递归占用调用堆栈
    + `不稳定`的排序算法

- 归并排序 (Merge Sort)
    + 归并排序是`分而治之`的排序算法
    ```
    基本思想：将待排序数组拆分成多个子数组，先将每个子数组排序，再将子数组之间排序，最后得到完整的有序数组。
    归并排序本质就是不断合并两个有序数组的过程，实现时主要分为两个过程：
    1. 拆分：递归的将当前数组二分，直到只剩下0或1个元素
    2. 归并：分别将左右半边数组排序，然后归并在一起形成一个大的有序数组
    ```
    + 时间复杂度都是O(nlgn)
    + 空间复杂度O(n)，需要一个大小为n的临时数组
    + `稳定`的排序算法

- 堆排序 (Heap Sort)
    + 堆排序是利用堆这种数据结构设计的算法。堆可以看做一个`完全二叉树`，它按`层级`在数组中存储，数组下标为k的
    节点的父节点位置分别为：
        - k 位置的`父节点`位置在(k-1)/2向下取整
        - k位置的`左子节点`位置在2k+1
        - k位置的`右子节点`位置在2k+2
    + `堆有序`的定义是每个节点都大于等于它的两个子节点，所以根节点是有序二叉堆中值最大的节点。
    堆排序就是一个不断移除根节点，使用数组剩余元素重新构建堆的过程，和选择排序有点类似（只不过
    按降序取元素）
    ```
    构建堆有序数组：
    1. 首先使用 (n-1)/2 之前的元素构建堆，完成后，整个堆最大元素位于数组的0下标位置
    2. 把数组首尾数据交换，此时数组最大值已找到（首位）
    3. 把堆的尺寸缩小1，重复1、2，知道堆的尺寸为1
    ```
    + 时间复杂度都是O(nlgn)
    + 空间复杂度O(1)
    + `不稳定`的排序算法

### 来源
> [力扣（LeetCode）](https://leetcode-cn.com/)

### 参考
> [学习排序算法](https://blog.csdn.net/weixin_44811417/article/details/90748011)