# [求众数](https://leetcode-cn.com/problems/majority-element/)

## 题目描述
    给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。

    你可以假设数组是非空的，并且给定的数组总是存在众数。

    示例 1:
    输入: [3,2,3]
    输出: 3
    
    示例 2:
    输入: [2,2,1,1,1,2,2]
    输出: 2

## 思路
- Hash表
    ```
    拿到题首先无脑方法，采用两次循环。第一个循环遍历数组将值放入map并计数，最后一个循环遍历map，找出值大于[n/2]的返回！
    可改为一个循环，直接在计数时找出大于[n/2]并返回（时间复杂度为O(n)）
    ```
    + 时间复杂度O(n^2)：两次循环
    + 空间复杂度为O(n)：需维护一个map，最多包含 n - ([n / 2] + 1)个元素

- 数组暴力解法
    ```
    直接双重循环，外面的循环定义当前元素出现的次数(count)，内循环寻找当前元素并计数，内循环结束后直接判断 count > [n / 2],满足返回该元素即可
    ```
    + 时间复杂度O(n^2)
    + 空间复杂度O(1)：暴力方式只有一个临时分配的计时器，没有分配与输入同等规模的额外空间

- 排序法
    ```
    直接对数组排序后取下标为 [n / 2] 的值返回
    ```
    + 时间复杂度O(nlgn): 排序开销
    + 空间复杂度O(1)或O(n): 数组可以就地排序则为1，否则需将数组拷贝后排序为n

- Boyer-Moore 投票算法
    ```
    参考leetcode题解
    如果我们把众数记为 +1+1 ，把其他数记为 -1−1 ，将它们全部加起来，显然和大于 0 ，从结果本身我们可以看出众数比其他数多。
    本质上， Boyer-Moore 算法就是找 nums 的一个后缀 sufsuf ，其中 suf[0]suf[0] 就是后缀中的众数。我们维护一个计数器，如果遇到一个我们目前的候选众数，就将计数器加一，否则减一。只要计数器等于 0 ，我们就将 nums 中之前访问的数字全部 忘记 ，并把下一个数字当做候选的众数。直观上这个算法不是特别明显为何是对的，我们先看下面这个例子（竖线用来划分每次计数器归零的情况）
    链接: https://leetcode-cn.com/problems/majority-element/solution/qiu-zhong-shu-by-leetcode-2/
    ```
    + 时间复杂度O(n)
    + 空间复杂度O(1)

### 来源
> [力扣（LeetCode）](https://leetcode-cn.com/)